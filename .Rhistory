column_names[, filter_value := lapply(used_name, function(nm) {
if (nm %in% names(filter_lookup)) filter_lookup[[nm]] else NA
})]
#Get the uels
all_uels = gdxrrw::rgdx(gdx_path,requestList = list(name=symbol,compress=T))$uels
# all_uels.dt=data.table(uel=1:length(all_uels),uel.name=all_uels)
#
# #construct the uels filter
# uels.filters = copy(all_uels)
# for (i in seq_len(nrow(column_names))) {
#   if (!is.na(column_names$filter_value[[i]][1])) {
#     uels.filters[[i]] <- c(column_names$filter_value[[i]])
#   }
# }
seq_len(nrow(column_names))
column_names
i=3
column_names$filter_value[[i]][1]
column_names$filter_value[[i]]
filter_vals <- column_names$filter_value[[i]]
filter_vals
grepl(paste(filter_vals, collapse = "|"), all_uels[[i]], ignore.case = TRUE)
all_uels[[i]]
read_from_gdx2 = function(symbol,gdx_path,filters=list(),custom_colnames=c(),value_colname="value",get_te=FALSE,get_ts=FALSE) {
if (!require(gdxrrw)) {    stop("gdxrrw not installed") }
if (!require(data.table)) {    stop("data.table not installed") }
# Check that the file exists
if (!file.exists(gdx_path)) {
stop(sprintf("GDX file does not exist: %s", gdx_path))
}
# Load the contents of the file
tmp1=gdxrrw::gdxInfo(gdx_path,dump = F,returnDF=T)
# Check if the symbol exists in sets or parameters
symbol_exists <- any(tolower(tmp1$sets$name) == tolower(symbol)) ||
any(tolower(tmp1$parameters$name) == tolower(symbol))
if (!symbol_exists) {
stop(sprintf("Symbol '%s' does not exist in GDX file: %s", symbol, gdx_path))
}
#check of the symbol is a set or a parameter and set the isSet value
##get the information from the set or parameter row
tmp2 = subset(tmp1$sets, tolower(name) == tolower(symbol))
if(nrow(tmp2)==0) {tmp2 = subset(tmp1$parameters, tolower(name) == tolower(symbol)); isSet=F  } else {isSet=T}
# Check that the custom_colnames are defined well
# Get the number of dimensions for the symbol (from sets or parameters)
domnames <- tmp2$domnames[[1]]
num_of_dims <- length(domnames)
if (!(length(custom_colnames) %in% c(0, num_of_dims))) {
stop(sprintf(
"custom_colnames must be either empty or have length equal to the number of dimensions (%d) for symbol '%s'. Provided: %d",
num_of_dims, symbol, length(custom_colnames)
))
}
#Create a structure that hold all the information about the columns (number of dimensipns, original name, custom and filters )
column_names = data.table(
col_num = 1:length(domnames),
gdx_column_name = domnames,
custom_colnames = if (length(custom_colnames) == 0) rep(NA_character_, length(domnames)) else custom_colnames
)
column_names[,used_name:=ifelse(is.na(custom_colnames),gdx_column_name,custom_colnames)]
column_names[used_name=="*",used_name:=paste0("V",col_num)]
# Prepare filters as a named list for easy lookup
filter_lookup <- setNames(filters, names(filters))
# Add filter_value column: NA if no filter, otherwise the filter value
column_names[, filter_value := lapply(used_name, function(nm) {
if (nm %in% names(filter_lookup)) filter_lookup[[nm]] else NA
})]
#Get the uels
all_uels = gdxrrw::rgdx(gdx_path,requestList = list(name=symbol,compress=T))$uels
# all_uels.dt=data.table(uel=1:length(all_uels),uel.name=all_uels)
#
# #construct the uels filter
# uels.filters = copy(all_uels)
# for (i in seq_len(nrow(column_names))) {
#   if (!is.na(column_names$filter_value[[i]][1])) {
#     uels.filters[[i]] <- c(column_names$filter_value[[i]])
#   }
# }
uels.filters = copy(all_uels)
for (i in seq_len(nrow(column_names))) {
filter_vals <- column_names$filter_value[[i]]
if (!is.na(filter_vals[1])) {
# Find case-insensitive matches
matches <- grepl(paste(filter_vals, collapse = "|"), all_uels[[i]], ignore.case = TRUE)
if (any(matches)) {
# Keep only matches
uels.filters[[i]] <- all_uels[[i]][matches]
} else {
# Warn and keep original
warning(
sprintf(
"No matches found for filter in column %d: %s. Keeping original UELs.",
i,
paste(filter_vals, collapse = ", ")
),
call. = FALSE
)
uels.filters[[i]] <- all_uels[[i]]
}
}
}
print(column_names)
str(uels.filters)
#load the data
b=rgdx(gdxName=gdx_path,
requestList = list(
name = symbol,
form="sparse",
uels=uels.filters
),
useDomInfo = T)
#convert to dt approach gpt
gdx_data <- as.data.table(b$val)
setnames(gdx_data, c(column_names$used_name, value_colname), skip_absent = TRUE)
for (i in seq_len(length(b$uels))) {
cur_col_name = column_names[col_num==i,used_name]
gdx_data[[cur_col_name]] <- factor(
b$uels[[i]][ gdx_data[[cur_col_name]] ],
levels = b$uels[[i]]
)
}
attr(gdx_data,"src_gdxfile") = gdx_path
attr(gdx_data,"filters") = filters
attr(gdx_data,"column_names") = column_names
attr(gdx_data,"uels.filters") = uels.filters
return(gdx_data)
}
read_from_gdx2("results",gdx_path = "E:/IFM_CAP2/Database2020/v.main2020/p.2025_4_GAECs_to_ECO/output/results.195_400.gdx",custom_colnames = c("FDALL","SCEN","variable","dim1","dim2","dim3","dim4"),filters = list(variable="modelname"))
read_from_gdx2("results",gdx_path = "E:/IFM_CAP2/Database2020/v.main2020/p.2025_4_GAECs_to_ECO/output/results.195_400.gdx",custom_colnames = c("FDALL","SCEN","variable","dim1","dim2","dim3","dim4"),filters = list(SCEN="NO_GAEC_ALL"))
read_from_gdx2("results",gdx_path = "E:/IFM_CAP2/Database2020/v.main2020/p.2025_4_GAECs_to_ECO/output/results.195_400.gdx",custom_colnames = c("FDALL","SCEN","variable","dim1","dim2","dim3","dim4"),filters = list(FDALL=c("80005990095207" ,"80005990095208")))
read_from_gdx2("results",gdx_path = "E:/IFM_CAP2/Database2020/v.main2020/p.2025_4_GAECs_to_ECO/output/results.195_400.gdx",custom_colnames = c("FDALL","SCEN","variable","dim1","dim2","dim3","dim4"),filters = list(FDALL=c("80005990095207" ,"80005990095208"),SCEN=c("BSL")))
read_from_gdx2("results",gdx_path = "E:/IFM_CAP2/Database2020/v.main2020/p.2025_4_GAECs_to_ECO/output/results.195_400.gdx",custom_colnames = c("FDALL","SCEN","variable","dim1","dim2","dim3","dim4"),filters = list(SCEN=c("BSL")))
read_from_gdx2 = function(symbol,gdx_path,filters=list(),custom_colnames=c(),value_colname="value",get_te=FALSE,get_ts=FALSE) {
if (!require(gdxrrw)) {    stop("gdxrrw not installed") }
if (!require(data.table)) {    stop("data.table not installed") }
# Check that the file exists
if (!file.exists(gdx_path)) {
stop(sprintf("GDX file does not exist: %s", gdx_path))
}
# Load the contents of the file
tmp1=gdxrrw::gdxInfo(gdx_path,dump = F,returnDF=T)
# Check if the symbol exists in sets or parameters
symbol_exists <- any(tolower(tmp1$sets$name) == tolower(symbol)) ||
any(tolower(tmp1$parameters$name) == tolower(symbol))
if (!symbol_exists) {
stop(sprintf("Symbol '%s' does not exist in GDX file: %s", symbol, gdx_path))
}
#check of the symbol is a set or a parameter and set the isSet value
##get the information from the set or parameter row
tmp2 = subset(tmp1$sets, tolower(name) == tolower(symbol))
if(nrow(tmp2)==0) {tmp2 = subset(tmp1$parameters, tolower(name) == tolower(symbol)); isSet=F  } else {isSet=T}
# Check that the custom_colnames are defined well
# Get the number of dimensions for the symbol (from sets or parameters)
domnames <- tmp2$domnames[[1]]
num_of_dims <- length(domnames)
if (!(length(custom_colnames) %in% c(0, num_of_dims))) {
stop(sprintf(
"custom_colnames must be either empty or have length equal to the number of dimensions (%d) for symbol '%s'. Provided: %d",
num_of_dims, symbol, length(custom_colnames)
))
}
#Create a structure that hold all the information about the columns (number of dimensipns, original name, custom and filters )
column_names = data.table(
col_num = 1:length(domnames),
gdx_column_name = domnames,
custom_colnames = if (length(custom_colnames) == 0) rep(NA_character_, length(domnames)) else custom_colnames
)
column_names[,used_name:=ifelse(is.na(custom_colnames),gdx_column_name,custom_colnames)]
column_names[used_name=="*",used_name:=paste0("V",col_num)]
# Prepare filters as a named list for easy lookup
filter_lookup <- setNames(filters, names(filters))
# Add filter_value column: NA if no filter, otherwise the filter value
column_names[, filter_value := lapply(used_name, function(nm) {
if (nm %in% names(filter_lookup)) filter_lookup[[nm]] else NA
})]
#Get the uels
all_uels = gdxrrw::rgdx(gdx_path,requestList = list(name=symbol,compress=T))$uels
uels.filters = copy(all_uels)
for (i in seq_len(nrow(column_names))) {
filter_vals <- column_names$filter_value[[i]]
if (!is.na(filter_vals[1])) {
# Find case-insensitive matches
matches <- grepl(paste(filter_vals, collapse = "|"), all_uels[[i]], ignore.case = TRUE)
if (any(matches)) {
# Keep only matches
uels.filters[[i]] <- all_uels[[i]][matches]
} else {
# Warn and keep original
warning(
sprintf(
"No matches found for filter in column %d: %s. Not applying the filter.",
i,
paste(filter_vals, collapse = ", ")
),
call. = FALSE
)
uels.filters[[i]] <- all_uels[[i]]
}
}
}
print(column_names)
str(uels.filters)
#load the data
b=rgdx(gdxName=gdx_path,
requestList = list(
name = symbol,
form="sparse",
uels=uels.filters
),
useDomInfo = T)
#convert to dt approach gpt
gdx_data <- as.data.table(b$val)
setnames(gdx_data, c(column_names$used_name, value_colname), skip_absent = TRUE)
for (i in seq_len(length(b$uels))) {
cur_col_name = column_names[col_num==i,used_name]
gdx_data[[cur_col_name]] <- factor(
b$uels[[i]][ gdx_data[[cur_col_name]] ],
levels = b$uels[[i]]
)
}
attr(gdx_data,"src_gdxfile") = gdx_path
attr(gdx_data,"filters") = filters
attr(gdx_data,"column_names") = column_names
attr(gdx_data,"uels.filters") = uels.filters
return(gdx_data)
}
read_from_gdx2("results",gdx_path = "E:/IFM_CAP2/Database2020/v.main2020/p.2025_4_GAECs_to_ECO/output/results.195_400.gdx",custom_colnames = c("FDALL","SCEN","variable","dim1","dim2","dim3","dim4"),filters = list(SCEN=c("BSLx")))
read_from_gdx2 = function(symbol,gdx_path,filters=list(),custom_colnames=c(),value_colname="value",get_te=FALSE,get_ts=FALSE) {
if (!require(gdxrrw)) {    stop("gdxrrw not installed") }
if (!require(data.table)) {    stop("data.table not installed") }
# Check that the file exists
if (!file.exists(gdx_path)) {
stop(sprintf("GDX file does not exist: %s", gdx_path))
}
# Load the contents of the file
tmp1=gdxrrw::gdxInfo(gdx_path,dump = F,returnDF=T)
# Check if the symbol exists in sets or parameters
symbol_exists <- any(tolower(tmp1$sets$name) == tolower(symbol)) ||
any(tolower(tmp1$parameters$name) == tolower(symbol))
if (!symbol_exists) {
stop(sprintf("Symbol '%s' does not exist in GDX file: %s", symbol, gdx_path))
}
#check of the symbol is a set or a parameter and set the isSet value
##get the information from the set or parameter row
tmp2 = subset(tmp1$sets, tolower(name) == tolower(symbol))
if(nrow(tmp2)==0) {tmp2 = subset(tmp1$parameters, tolower(name) == tolower(symbol)); isSet=F  } else {isSet=T}
# Check that the custom_colnames are defined well
# Get the number of dimensions for the symbol (from sets or parameters)
domnames <- tmp2$domnames[[1]]
num_of_dims <- length(domnames)
if (!(length(custom_colnames) %in% c(0, num_of_dims))) {
stop(sprintf(
"custom_colnames must be either empty or have length equal to the number of dimensions (%d) for symbol '%s'. Provided: %d",
num_of_dims, symbol, length(custom_colnames)
))
}
#Create a structure that hold all the information about the columns (number of dimensipns, original name, custom and filters )
column_names = data.table(
col_num = 1:length(domnames),
gdx_column_name = domnames,
custom_colnames = if (length(custom_colnames) == 0) rep(NA_character_, length(domnames)) else custom_colnames
)
column_names[,used_name:=ifelse(is.na(custom_colnames),gdx_column_name,custom_colnames)]
column_names[used_name=="*",used_name:=paste0("V",col_num)]
# Prepare filters as a named list for easy lookup
filter_lookup <- setNames(filters, names(filters))
# Add filter_value column: NA if no filter, otherwise the filter value
column_names[, filter_value := lapply(used_name, function(nm) {
if (nm %in% names(filter_lookup)) filter_lookup[[nm]] else NA
})]
#Get the uels
all_uels = gdxrrw::rgdx(gdx_path,requestList = list(name=symbol,compress=T))$uels
uels.filters = copy(all_uels)
for (i in seq_len(nrow(column_names))) {
filter_vals <- column_names$filter_value[[i]]
if (!is.na(filter_vals[1])) {
# Find case-insensitive matches
matches <- grepl(paste(filter_vals, collapse = "|"), all_uels[[i]], ignore.case = TRUE)
if (any(matches)) {
# Keep only matches
uels.filters[[i]] <- all_uels[[i]][matches]
} else {
# Warn and keep original
warning(
sprintf(
"No matches found for value in column %d: %s. Not applying the filter.",
column_names[col_num==i,used_name],
paste(filter_vals, collapse = ", ")
),
call. = FALSE
)
uels.filters[[i]] <- all_uels[[i]]
}
}
}
print(column_names)
str(uels.filters)
#load the data
b=rgdx(gdxName=gdx_path,
requestList = list(
name = symbol,
form="sparse",
uels=uels.filters
),
useDomInfo = T)
#convert to dt approach gpt
gdx_data <- as.data.table(b$val)
setnames(gdx_data, c(column_names$used_name, value_colname), skip_absent = TRUE)
for (i in seq_len(length(b$uels))) {
cur_col_name = column_names[col_num==i,used_name]
gdx_data[[cur_col_name]] <- factor(
b$uels[[i]][ gdx_data[[cur_col_name]] ],
levels = b$uels[[i]]
)
}
attr(gdx_data,"src_gdxfile") = gdx_path
attr(gdx_data,"filters") = filters
attr(gdx_data,"column_names") = column_names
attr(gdx_data,"uels.filters") = uels.filters
return(gdx_data)
}
read_from_gdx2("results",gdx_path = "E:/IFM_CAP2/Database2020/v.main2020/p.2025_4_GAECs_to_ECO/output/results.195_400.gdx",custom_colnames = c("FDALL","SCEN","variable","dim1","dim2","dim3","dim4"),filters = list(SCEN=c("BSLx")))
read_from_gdx2 = function(symbol,gdx_path,filters=list(),custom_colnames=c(),value_colname="value",get_te=FALSE,get_ts=FALSE) {
if (!require(gdxrrw)) {    stop("gdxrrw not installed") }
if (!require(data.table)) {    stop("data.table not installed") }
# Check that the file exists
if (!file.exists(gdx_path)) {
stop(sprintf("GDX file does not exist: %s", gdx_path))
}
# Load the contents of the file
tmp1=gdxrrw::gdxInfo(gdx_path,dump = F,returnDF=T)
# Check if the symbol exists in sets or parameters
symbol_exists <- any(tolower(tmp1$sets$name) == tolower(symbol)) ||
any(tolower(tmp1$parameters$name) == tolower(symbol))
if (!symbol_exists) {
stop(sprintf("Symbol '%s' does not exist in GDX file: %s", symbol, gdx_path))
}
#check of the symbol is a set or a parameter and set the isSet value
##get the information from the set or parameter row
tmp2 = subset(tmp1$sets, tolower(name) == tolower(symbol))
if(nrow(tmp2)==0) {tmp2 = subset(tmp1$parameters, tolower(name) == tolower(symbol)); isSet=F  } else {isSet=T}
# Check that the custom_colnames are defined well
# Get the number of dimensions for the symbol (from sets or parameters)
domnames <- tmp2$domnames[[1]]
num_of_dims <- length(domnames)
if (!(length(custom_colnames) %in% c(0, num_of_dims))) {
stop(sprintf(
"custom_colnames must be either empty or have length equal to the number of dimensions (%d) for symbol '%s'. Provided: %d",
num_of_dims, symbol, length(custom_colnames)
))
}
#Create a structure that hold all the information about the columns (number of dimensipns, original name, custom and filters )
column_names = data.table(
col_num = 1:length(domnames),
gdx_column_name = domnames,
custom_colnames = if (length(custom_colnames) == 0) rep(NA_character_, length(domnames)) else custom_colnames
)
column_names[,used_name:=ifelse(is.na(custom_colnames),gdx_column_name,custom_colnames)]
column_names[used_name=="*",used_name:=paste0("V",col_num)]
# Prepare filters as a named list for easy lookup
filter_lookup <- setNames(filters, names(filters))
# Add filter_value column: NA if no filter, otherwise the filter value
column_names[, filter_value := lapply(used_name, function(nm) {
if (nm %in% names(filter_lookup)) filter_lookup[[nm]] else NA
})]
#Get the uels
all_uels = gdxrrw::rgdx(gdx_path,requestList = list(name=symbol,compress=T))$uels
uels.filters = copy(all_uels)
for (i in seq_len(nrow(column_names))) {
filter_vals <- column_names$filter_value[[i]]
if (!is.na(filter_vals[1])) {
# Find case-insensitive matches
matches <- grepl(paste(filter_vals, collapse = "|"), all_uels[[i]], ignore.case = TRUE)
if (any(matches)) {
# Keep only matches
uels.filters[[i]] <- all_uels[[i]][matches]
} else {
# Warn and keep original
warning(
sprintf(
"No matches found for value in column %s: %s. Not applying the filter.",
column_names[col_num==i,used_name],
paste(filter_vals, collapse = ", ")
),
call. = FALSE
)
uels.filters[[i]] <- all_uels[[i]]
}
}
}
print(column_names)
str(uels.filters)
#load the data
b=rgdx(gdxName=gdx_path,
requestList = list(
name = symbol,
form="sparse",
uels=uels.filters
),
useDomInfo = T)
#convert to dt approach gpt
gdx_data <- as.data.table(b$val)
setnames(gdx_data, c(column_names$used_name, value_colname), skip_absent = TRUE)
for (i in seq_len(length(b$uels))) {
cur_col_name = column_names[col_num==i,used_name]
gdx_data[[cur_col_name]] <- factor(
b$uels[[i]][ gdx_data[[cur_col_name]] ],
levels = b$uels[[i]]
)
}
attr(gdx_data,"src_gdxfile") = gdx_path
attr(gdx_data,"filters") = filters
attr(gdx_data,"column_names") = column_names
attr(gdx_data,"uels.filters") = uels.filters
return(gdx_data)
}
read_from_gdx2("results",gdx_path = "E:/IFM_CAP2/Database2020/v.main2020/p.2025_4_GAECs_to_ECO/output/results.195_400.gdx",custom_colnames = c("FDALL","SCEN","variable","dim1","dim2","dim3","dim4"),filters = list(SCEN=c("BSLx")))
read_from_gdx2 = function(symbol,gdx_path,filters=list(),custom_colnames=c(),value_colname="value",get_te=FALSE,get_ts=FALSE) {
if (!require(gdxrrw)) {    stop("gdxrrw not installed") }
if (!require(data.table)) {    stop("data.table not installed") }
# Check that the file exists
if (!file.exists(gdx_path)) {
stop(sprintf("GDX file does not exist: %s", gdx_path))
}
# Load the contents of the file
tmp1=gdxrrw::gdxInfo(gdx_path,dump = F,returnDF=T)
# Check if the symbol exists in sets or parameters
symbol_exists <- any(tolower(tmp1$sets$name) == tolower(symbol)) ||
any(tolower(tmp1$parameters$name) == tolower(symbol))
if (!symbol_exists) {
stop(sprintf("Symbol '%s' does not exist in GDX file: %s", symbol, gdx_path))
}
#check of the symbol is a set or a parameter and set the isSet value
##get the information from the set or parameter row
tmp2 = subset(tmp1$sets, tolower(name) == tolower(symbol))
if(nrow(tmp2)==0) {tmp2 = subset(tmp1$parameters, tolower(name) == tolower(symbol)); isSet=F  } else {isSet=T}
# Check that the custom_colnames are defined well
# Get the number of dimensions for the symbol (from sets or parameters)
domnames <- tmp2$domnames[[1]]
num_of_dims <- length(domnames)
if (!(length(custom_colnames) %in% c(0, num_of_dims))) {
stop(sprintf(
"custom_colnames must be either empty or have length equal to the number of dimensions (%d) for symbol '%s'. Provided: %d",
num_of_dims, symbol, length(custom_colnames)
))
}
#Create a structure that hold all the information about the columns (number of dimensipns, original name, custom and filters )
column_names = data.table(
col_num = 1:length(domnames),
gdx_column_name = domnames,
custom_colnames = if (length(custom_colnames) == 0) rep(NA_character_, length(domnames)) else custom_colnames
)
column_names[,used_name:=ifelse(is.na(custom_colnames),gdx_column_name,custom_colnames)]
column_names[used_name=="*",used_name:=paste0("V",col_num)]
# Prepare filters as a named list for easy lookup
filter_lookup <- setNames(filters, names(filters))
# Add filter_value column: NA if no filter, otherwise the filter value
column_names[, filter_value := lapply(used_name, function(nm) {
if (nm %in% names(filter_lookup)) filter_lookup[[nm]] else NA
})]
#Get the uels
all_uels = gdxrrw::rgdx(gdx_path,requestList = list(name=symbol,compress=T))$uels
uels.filters = copy(all_uels)
for (i in seq_len(nrow(column_names))) {
filter_vals <- column_names$filter_value[[i]]
if (!is.na(filter_vals[1])) {
# Find case-insensitive matches
matches <- grepl(paste(filter_vals, collapse = "|"), all_uels[[i]], ignore.case = TRUE)
if (any(matches)) {
# Keep only matches
uels.filters[[i]] <- all_uels[[i]][matches]
} else {
# Warn and keep original
warning(
sprintf(
"No matches found for value in column %s: '%s'. Not applying the filter.",
column_names[col_num==i,used_name],
paste(filter_vals, collapse = ", ")
),
call. = FALSE
)
uels.filters[[i]] <- all_uels[[i]]
}
}
}
print(column_names)
str(uels.filters)
#load the data
b=rgdx(gdxName=gdx_path,
requestList = list(
name = symbol,
form="sparse",
uels=uels.filters
),
useDomInfo = T)
#convert to dt approach gpt
gdx_data <- as.data.table(b$val)
setnames(gdx_data, c(column_names$used_name, value_colname), skip_absent = TRUE)
for (i in seq_len(length(b$uels))) {
cur_col_name = column_names[col_num==i,used_name]
gdx_data[[cur_col_name]] <- factor(
b$uels[[i]][ gdx_data[[cur_col_name]] ],
levels = b$uels[[i]]
)
}
attr(gdx_data,"src_gdxfile") = gdx_path
attr(gdx_data,"filters") = filters
attr(gdx_data,"column_names") = column_names
attr(gdx_data,"uels.filters") = uels.filters
return(gdx_data)
}
read_from_gdx2("results",gdx_path = "E:/IFM_CAP2/Database2020/v.main2020/p.2025_4_GAECs_to_ECO/output/results.195_400.gdx",custom_colnames = c("FDALL","SCEN","variable","dim1","dim2","dim3","dim4"),filters = list(SCEN=c("BSLx")))
read_from_gdx2("results",gdx_path = "E:/IFM_CAP2/Database2020/v.main2020/p.2025_4_GAECs_to_ECO/output/results.195_400.gdx",custom_colnames = c("FDALL","SCEN","variable","dim1","dim2","dim3","dim4"),filters = list(SCEN=c("BSL")))
